# Java 垃圾收集机制（GC）——对象判定、收集算法、垃圾收集器

> 写在前面：本文权当笔者学习 Java 过程的总结整理，因此，若有不严谨、错误之处，还望不吝指出。

垃圾收集（Garbage Collection, GC），内存分配与回收技术已自动化，但当垃圾收集成为系统达到更高并发量的瓶颈时，就需要我们对GC实施必要的监控和调节。

**主要内容：**

```
一. 判定回收对象
    1. 引用判定算法
    2. 引用对象类型
    3. 引用“缓刑”
    4. 方法区垃圾回收
二. 垃圾收集算法
    1. 标记-清理算法
    2. 复制算法
    3. 标记-整理算法
    4. 分代收集算法
三. 垃圾收集器
    1. Serial
    2. ParNew
    3. Parallel Scavenge
    4. Serial Old
    5. Parallel Old
    6. CMS
    7. G1
```

## 一. 判定回收对象

垃圾回收前，首先需要判断该对象实例是否已死，是否需要回收。那么如何判定？

### 1. 引用判定算法

#### 1.1 引用计数算法

给对象中添加一个引用计数器，每有一个地方引用它，计数器加 1；当引用失效时，计数器减 1；在任何时刻计数器都为 0 时，则判定该对象已死，通知内存回收。

该算法实现简单，判定效率高，但是很难解决对象之间相互循环引用问题。

比如，`objA.instance  = objB; objB.instance = objA` ，实际上这两个对象已经不可能再被访问，但是它们因为互相引用，计数器不为 0，导致无法通知 GC 收集器回收。

#### 1.2 根搜索算法

主流的商用程序语言中，多是使用根搜索算法（GC Root Tracing）判定对象是否存活。思路就是通过一系列的名为 “GC Roots“ 的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径为引用链（Reference Chain），当一个对象到 GC Roots 没有任何引用链，则证明此对象是不可用的。

在 Java 语言，可作为 GC Roots 的对象包括：

* 虚拟机栈（栈帧中的本地变量表）中引用的对象
* 方法区中的类静态属性引用的对象
* 方法区中的常量引用的对象
* 本地方法栈中 JNI（即一般说的Native方法）的引用对象

### 2. 引用类型

判定对象是否已死需要回收，不仅需要引用计数算法或根搜索算法进行判定，还与对象引用类型有关。

Java 引用类型分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）四种，强度依次减弱。

#### 2.1 强引用

强引用的定义，比如：

`Object obj = new Object()`

只要引用存在，垃圾收集器就不会回收该引用的实例对象。除非 `obj` 已释放，收集器才会对 `new Object()` 开辟的实例空间进行回收。

#### 2.2 软引用

软引用的定义可通过：

```
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
```

软引用为非必须引用，内存溢出前，进行回收。因此，常用来实现类似缓存的功能：若内存足够的情况下，直接获取该软引用的实例对象；内存不足的情况下，则该对象返回为空，只能从数据源查询。

```
因此，接上
obj = null; // 释放 obj
sf.get();   // 内存溢出前，对象被回收，返回 null
```

#### 2.3 弱引用

弱引用的定义，可通过：

```
Object obj = new Object();
WeakReference<Object> wf = new WeakReference<Object>(obj);
```

其所关联的对象只能生存到第二次垃圾收集（先标记），无论内存是否足够。

#### 2.4 虚引用

虚引用的定义，可通过：

```
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj);
```

该引用通过 `get()` 方法获得的永远是 `null`，因此无法通过虚引用取得一个对象实例，每次垃圾收集时都会被回收，因此虚引用主要用来检测对象是否已被回收，并且在被回收时收到一个系统通知。

### 3. 引用 ”缓刑“

在根搜索算法中判定为不可达对象，也并非”非死不可“，真正宣告死亡，至少需要两次标记：

第一次发现该对象没有与 GC Roots 相连接的引用链后，那么对该对象进行第一次标记，并且判定是否需要执行 `finalize()`——如果该对象没有覆盖 `finalize()`，或者已被调用过一次，则直接宣判死亡；否则将该对象放进`F-Queue` 队列，等待 `Finalizer` 线程区执行促发，促发时，若重新与引用链任何一个对象建立联系，则第二次垃圾收集时，将该对象移出待回收集合，否则进行第二次标记后垃圾回收。

但并不建议通过 `finalize()` 拯救对象，因为运行代价高昂，不确定性大，无法保证各个对象的调用顺序。

## 4. 方法区垃圾回收

方法区的回收内容主要为：废弃常量和无用的类。废弃常量的回收与堆的对象回收类似，而无用类的判定需要满足：

```
1. 该类所有的实例都已经被回收，也就是 java 堆中不存在该类的任何实例。
2. 加载该类的 ClassLoader 已经被回收。
3. 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
```

## 二. 垃圾收集算法

### 1. 标记-清除算法

垃圾回收时，首先标记需要回收的对象，完成后统一回收所有标记的对象。

缺点有二：

* 效率，标记和清除的执行效率都不高
* 空间，产生大量不连续的内存碎片

![](pics/1.png)

### 2. 复制算法

为了解决以上问题，复制算法应运而生，它将可用的内存容量划分为大小相等的两块，每次只使用其中一块。当这块内存用完，就将还存活的对象复制到另一块上面，然后再把该块内存空间一次清理掉。

该算法每次都是对其中一块进行内存回收，简单高效，但是缺点也明显：***每次都要将可用内存缩小为原来的一半***。

现有的商业虚拟机在回收新生代多采用该算法，因为新生代的对象实例多“朝生夕死”。只是不同公司认为划分的比例不同：IBM 认为新生代的 98% 对象朝生夕死，因此采用一块较大的 Eden 空间和两块较小的 Survivor 空间的划分方式；而 HotSpot 则认为比例是 8 ：1。

![](pics/2.png)

### 3. 标记-整理算法

复制算法在对象存活率高时就需要执行多次复制操作，效率变低，且为了不浪费一半空间。根据老年代特点，标记-整理算法应运而生。

与标记-清理算法类似，不同的是标记后，该算法不是直接清理，而是将所有存活的对象都移向一端，然后清理掉端边界以外的内存。

![](pics/3.png)

### 4. 分代收集算法

根据对象的存活周期，把 Java 堆分为新生代和老年代。这样，可以根据各个年代的特点采用适合的手机算法。

新生代中，对象“朝生夕死”，仅少量存货，因此选用复制算法进行回收。

老年代中，对象存活率高、没有额外空格键对它进行分配担保，因此选用“标记-清理”或“标记-整理”算法进行回收。

## 三. 垃圾收集器

垃圾收集器是垃圾收集算法的具体实现，不同厂商版本的虚拟机所提供的垃圾收集器可能会有很大差别。

### 1. Serial 收集器

Serial 收集器是最基本，历史最为悠久的收集器。该收集器是个单线程的收集器，执行垃圾收集时，必须暂停其他所有的工作线程，即"Stop The World"。

![](pics/4.png)

实际上，Serial 收集器到现在为止，它依然是虚拟机运行在 Client 模式下的默认新生代收集器，因为用户的应用场景中，分配给虚拟机管理的内存一般来说不大，新生代垃圾有限，停顿时间可接受，是个简单高效的选择。

### 2.  ParNew 收集器

ParNew 收集器其实是 Serial 收集器的多线程版本，除此，包括Serial的可用控制参数、收集算法、Stop The World等，都与 Serial 完全相同。

![](pics/5.png)

ParNew是许多运行在 Server 模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关但十分重要的是，目前只有它可与 CMS 收集器配合。

ParNew 收集器在单 CPU 的环境中绝对不会比 Serial 收集器更好的效果，甚至由于存在线程交互的开销，该收集器通过超线程技术实现的两个 CPU 的环境都不能百分之百地保证能超越 Serial 收集器。当然，随着 CPU 数量的使用增加，它对于 GC 时系统资源的利用还是由很多好处。它默认开启的线程数与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数限制收集的线程数。

### 3. Parallel Scavenge 收集器

Parallel Scavenge 也是一个新生代收集器，同样采用复制算法，又是并行的多线程收集器，这些与 ParNew 一样。

Parallel Scavenge 的特点在于它的关注点与其他收集器不同，CMS 等收集器的关注点尽可能地缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 收集器的目标则是达到一个可控制的吞吐量。所谓吞吐量就是 `吞吐量 = 运行用户代码时间 / （运行用户代码时间 + 垃圾收集时间）。

停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户的体验；而高吞吐量则可以最高效率地运用 CPU 时间，尽快地完成程序的运算任务，主要适合在后台计算而不需要太多交互的任务。

由于与吞吐量关系密切，该收集器也被称为 “吞吐量优先“ 收集器。

### 4. Serial Old 收集器

Serial Old 是 Serial 收集器的老年代版本，同样是一个单线程收集器，采用“标记-整理”算法。这个收集器主要也是在 Client 模式下的虚拟机使用；如果使用在 Server 模式下，主要还有两大用途：一个是 JDK1.5 版本之前与 Parallel Scavenge 收集器搭配，另一个则是作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Filure 使用时候。

![](pics/6.png)

### 5. Parallel Old 收集器

Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和“标记-整理”算法。该收集器在 JDK 1.6 中才开始提供，之前新生代 Parallel Scavenge 一直搭配 Serial Old 使用。由于 Serial Old 单线程在服务端应用性能上的拖累，即便使用了 Parallel Scavenge 收集器也未必能在整体应用上获得吞吐量最大化的效果。

直到 Parallel Old 收集器出现以后，吞吐量优先收集器终于有了比较名副其实的应用组合，在注重吞吐量及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。

![](pics/7.png)

### 6. CMS 收集器

CMS(Concurrent Mark Sweep) 收集器从名字上就可以看出，是基于"标记-清除"算法，它是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分 Java 应用都集中在互联网站或 B/S 系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，给用户较好的体验。

运作过程相对于其他几种收集器来说更复杂一些，分为4个步骤：

1. 初始标记(CMS initial mark)
2. 并发标记(CMS concurrent mark)
3. 重新标记(CMS remark)
4. 并发清除(CMS concurrent sweep)

其中，初始标记、重新标记这两个步骤仍然需要 “Stop The World"。初始标记仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，并发标记阶段就是进行 GC Roots Tracing 过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象标记记录，这个阶段的停顿时间一般会比初始标记稍微长一点，但远比并发标记时间短。

![](pics/8.png)

CMS 的主要优点：并发收集、低停顿。但也有三个显著缺点：

* CMS 收集器对 CPU 资源非常敏感。为了解决该问题，虚拟机提供了增量式并发收集器（Incremental Concurrent Mark Sweep / i-CMS）的 CMS 收集器变种，所做的事情与单 CPU 年代 pc 机操作系统使用抢占式模拟多任务机制的思想一样，就是在并发标记和并发清理的时候让 GC 线程、用户线程交替运行，尽量减少 GC 线程独占资源的时间，这样整个垃圾收集的过程会更长，但对用户程序的影响就会显得少一点。但是目前版本中，i-CMS 已经被声明为 deprecated，即不再提倡用户使用。
* CMS 收集器无法处理浮动垃圾，可能出现 Concurrent Mode Failure 失败而导致另一次 Full GC 的产生。由于 CMS 并发清理阶段用户线程一起正在运行，因此同时还会有新的垃圾不断产生，这一部分垃圾出现在标记过后， CMS 无法在本次收集中处理它们，只好留下一次 GC 时再将其清理掉，这部分垃圾就叫浮动垃圾。要是 CMS 运行期间预留的内存无法满足程序需要，就会出现 Concurrent Mode Failure 失败，这时候虚拟机将启动后备预案：临时启用 Serial Old 收集器来重新进行老年代垃圾收集。
* 该收集器基于标记-清理算法，因此收集结束时产生大量的空间碎片。碎片过多时，会给大对象的内存分配时带来许多麻烦，当无法找到足够大的连续空间进行分配时，不得不触发 Full GC。为了解决这个问题，收集器提供了一个开关参数，可在Full GC服务之后额外免费附送一个碎片整理过程。

### 7. G1 收集器

G1 收集器在 JDK 1.7 正式发布，它与 CMS 相比，有两个显著改进：一是基于 “标记-整理” 算法实现的收集器，因此不会产生空间碎片，这对于长时间运行的应用系统来说非常重要；二是可以非常准确地控制停顿，既能让使用者明确制定在一个长度 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 浩渺，这几乎已经是实时 Java(RTSJ) 的垃圾收集器特征。

G1 收集器能够在基本不牺牲吞吐量的前提下完成低停顿的内存回收，主要以由于，与其他收集器手机的范围是整个新生代或老年代不同，G1 将整个 Java 堆（包括新生代、老年代）划分为多个大小固定的独立区域，并且跟踪这些区域里面的垃圾堆积成都，在后台维护一个优先级列表，每次根据允许的收集时间，优先回收垃圾最多的区域。